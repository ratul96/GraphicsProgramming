#version 430 core
// Input per-fragment data
// These must correspond to the varying outputs from the vertex shader
in vec3 vNormalV;
in vec3 eyeSpaceLightPosV;
in vec3 eyeSpaceVertPosV;
in vec2 texCoord;
in vec3 FragPos;
/*struct Material{

	sampler2D diffuse;
	sampler2D specular;
	float shininess;
};
uniform Material material;

struct DirLight{

	
	vec3 direction;
	
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
};
uniform DirLight dirLight;
vec3 CalcDirLight(DirLight light,vec3 normal,vec3 viewDir);

struct PointLight{
	vec3 position;
		
	float constant;
	float linear;
	float quadratic;

	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
};
#define NR_POINT_LIGHTS 4
uniform PointLight pointLight[NR_POINT_LIGHTS];
vec3 CalcPointLight(PointLight light,vec3 normal,vec3 fragPos,vec3 viewDir);

struct SpotLight{
	vec3 position;
	vec3 direction;
	float cutOff;
	float outerCutOff;
	
	float constant;
	float linear;
	float quadratic;
	
	vec3  ambient;
	vec3  diffuse;
	vec3  specular;
};
uniform SpotLight spotLight;
vec3 CalcSpotLight(SpotLight light,vec3 normal,vec3 fragPos,vec3 viewDir);


// Input uniform data - these have values that will be the same for every fragment
uniform vec3 lightColour = {0.8,0.8,0.8};
uniform vec3 emissiveColour = {0,0,0};
uniform vec3 ambientColour  = {0.1f,0.1f,0.2f};
uniform vec3 diffuseColour  = {1.0f,1.0f,1.0f};
uniform vec3 specularColour = {1.0f,1.0f,1.0f};
uniform float shininess     = 50.0f;
uniform float alpha         = 1.0f;
uniform float ambientStrength=0.5f;
uniform vec3 viewPos;*/

// The output of the fragment shader is the fragment's colour
out vec4 fragColour;

float near=0.1;
float far=100.0;

/*float linearDepth(float depth)
{
	float z=depth*2.0-1.0;
	return(2.0*near*far)/(far+near-z*(far-near));
}*/

// This is another input to allow us to access a texture
uniform sampler2D tex1;



void main()
{

	/*// Ensure the normal is a unit vector
	vec3 normal = normalize( vNormalV );
	
	// properties
	vec3 viewDir=normalize(viewPos-FragPos);
	
	// Direction from eye to sample point
	vec3 eyeDir = normalize( -eyeSpaceVertPosV );
	
	// Retrieve colour from texture
	vec3 texColour = vec3(texture(tex1,vec2(texCoord.x,1-texCoord.y)));

	vec3 result={0.0f,0.0f,0.0f};
	//Directional Lighting
	 result+=CalcDirLight(dirLight,normal,viewDir);

	//PointLight
	for(int i=0;i<NR_POINT_LIGHTS;i++)
	{
		result += CalcPointLight(pointLight[i],normal,FragPos,viewDir);
	}
	
	//SpotLight
	result+=CalcSpotLight(spotLight,normal,FragPos,viewDir);*/
			
	//output the resultant light
	/*float depth=linearDepth(gl_FragCoord.z)/far*/;
	fragColour=vec4(0.04,0.28,0.26,1.0);
	
}

/*vec3 CalcDirLight(DirLight light,vec3 normal,vec3 viewDir)
{
	vec3 lightDir=normalize(-light.direction);

	//diffuse shading
	float diff=max(dot(normal,lightDir),0.0);

	//specular shading
	vec3 reflectDir=reflect(-lightDir,normal);
	float spec=pow(max(dot(viewDir,reflectDir),0.0),material.shininess);

	//combining results
	vec3 ambient=light.ambient*vec3(texture(material.diffuse,texCoord));
	vec3 diffuse = light.diffuse*diff*vec3(texture(material.diffuse,texCoord));
	vec3 specular = light.specular*spec*vec3(texture(material.specular,texCoord));
	return(ambient+diffuse+specular);
}

vec3 CalcPointLight(PointLight light,vec3 normal,vec3 fragPos,vec3 viewDir)
{
	vec3 lightDir = normalize( light.position - fragPos );
	
	//diffuse shading
	float diff=max(dot(normal,lightDir),0.0);
	
	//specular shading
	vec3 reflectDir=reflect(-lightDir,normal);
	float spec=pow(max(dot(viewDir,reflectDir),0.0),material.shininess);
	
	//calculate attenuation
	float distance=length(light.position-fragPos);
	float attenuation=1.0/(light.constant+light.linear*distance+light.quadratic*(distance*distance));

	//combining results
	vec3 ambient=light.ambient*vec3(texture(material.diffuse,texCoord));
	vec3 diffuse=light.diffuse*diff*vec3(texture(material.diffuse,texCoord));
	vec3 specular=light.specular*spec*vec3(texture(material.specular,texCoord));

	diffuse *=attenuation;
	ambient *=attenuation;
	specular *=attenuation;

	return(ambient+diffuse+specular);
	
}
vec3 CalcSpotLight(SpotLight light,vec3 normal,vec3 fragPos,vec3 viewDir)
{
	vec3 lightDir=normalize(light.position-fragPos);
	
	//diffuse shading
	float diff=max(dot(normal,lightDir),0.0);
	
	//specular shading
	vec3 reflectDir=reflect(-lightDir,normal);
	float spec=pow(max(dot(viewDir,reflectDir),0.0),material.shininess);
	
	//calculate attenuation
	float distance=length(light.position-fragPos);
	float attenuation=1.0/(light.constant+light.linear*distance+light.quadratic*(distance*distance));

	//calculate spotlight intensity
	float theta=dot(lightDir,normalize(-light.direction));
	float epsilon=light.cutOff-light.outerCutOff;
	float intensity=clamp((theta-light.outerCutOff)/epsilon,0.0,1.0);

	//combining results
	vec3 ambient=light.ambient*vec3(texture(material.diffuse,texCoord));
	vec3 diffuse=light.diffuse*diff*vec3(texture(material.diffuse,texCoord));
	vec3 specular=light.specular*spec*vec3(texture(material.specular,texCoord));

	ambient*=attenuation*intensity;
	diffuse*=attenuation*intensity;
	specular*=attenuation*intensity;

	return(ambient+diffuse+specular);
}*/

